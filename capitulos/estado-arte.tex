
\chapter*{Estado del arte}
\label{chapter:estado}
\addcontentsline{toc}{chapter}{\nameref{chapter:estado}}

En esta sección se describen algunos trabajos sobre el modelo de seguridad de
Android. \textit{A priori}, podemos distinguir dos grandes grupos: aquellos que
reportan alguna falla puntual del sistema y los que buscan dar una descripción
más general del mismo, ya sea de manera formal o informal\footnote{Entendemos
por enfoque informal a aquellos enfoques que no utilizan métodos formales para
el estudio de la plataforma.}.

\subsection*{Fallas puntuales}

Dentro del primer grupo mencionado podemos encontrar bla bla bla. TODO: Buscar
trabajos que apunten a vulnerabilidades específicas. El paper de Bagheri
\cite{bagheri} tiene muchas referencias a este tipo de trabajos.

\subsection*{Enfoque informal}

Por otro lado, encontramos trabajos como el de William Enck
\textit{et al.}~\cite{enck}, uno de los primeros artículos académicos en
describir el modelo de seguridad de Android. A través de esta descripción, los
autores buscaban \textit{desenmascarar} la complejidad a la que debían
enfrentarse los desarrolladores a la hora de construir aplicaciones seguras.

\todo{Leer con más detalle \cite{sok} y ver si vale la pena profundizar}
Dentro de esta línea también se encuentra el trabajo de Yasemin Acar \textit{et
al.}~\cite{sok}, quienes presentan una visión sistémica e integradora de las
distintas líneas de investigación en seguridad de Android. Los autores realizan
un análisis de los distintos enfoques desde los cuales se aborda la seguridad de
este tipo de sistemas, comparándolos y estableciendo, según ellos, las bases para
que la investigación futura pueda ser unificada.

Recientemente, René Mayrhofer \textit{et al.}~\cite{mayrhofer} publicaron un
trabajo de características similares a los anteriores basado en la versión 9.0
de Android. El mismo, además de dar un descripción detallada del modelo, incluye
una discusión de sus implicaciones y un posterior análisis sobre las medidas que
se tomaron a lo largo del tiempo para mitigar distintas amenazas.

Este tipo de trabajos constituyen un complemento importante a la documentación
oficial de Android, brindándole nuevas herramientas y referencias más claras a
los desarrolladores. Un ejemplo de esto fue el trabajo de Felt \textit{et
al.}~\cite{felt}, quienes estudiaron un grupo de aplicaciones disponibles para
la versión 2.2 de Android y detectaron que muchas de ellas pedían más permisos
de los que realmente necesitaban. Los autores investigaron las causas de
sobreprivilegio de estas aplicaciones y encontraron que muchas veces, los
desarrolladores intentaban otorgar la menor cantidad de privilegios necesarios
pero en reiteradas ocasiones fallaban por falta de una documentación precisa. En
consecuencia, el grupo desarrolló Stowaway, una de las primeras herramientas
dedicadas a la detección de permisos innecesarios.

\todo{Aclarar finalidad de las herramientas}
%
Actualmente existe una gran cantidad de herramientas de análisis estático,
siendo las más recientes: M-Perm~\cite{mperm}; IC3~\cite{ic3}, que incorpora el
concepto de \textit{propagación de constantes compuestas multi-valuadas} para
lograr una mayor eficiencia; Covert~\cite{covert} y Separ~\cite{separ}, que
combinan análisis estático con métodos formales para inferir automáticamente
propiedades sobre un conjunto de aplicaciones, a partir de las cuales se
derivarán políticas de seguridad; y Droidtector~\cite{droidtector}, que a
diferencia del resto no necesita el código fuente de las aplicaciones o de
Android. Las herramientas de este tipo se focalizan en estudiar una aplicación en
particular (o en algunos casos, un conjunto de aplicaicones) y extraer
propiedades de seguridad que solo conciernen a ella. En cambio, en esta tesina
estudiamos el sistema de permisos subyacente, extrayendo propiedades relevantes
para todas las aplicaciones y para el sistema en general.


\subsection*{Enfoque formal}
Uno de los primeros trabajos en abordar la seguridad de Android desde los
métodos formales fue el de Chaudhuri~\cite{chaudhuri}. En el mismo, se desarrolló
un lenguaje que permite describir un subconjunto de aplicaciones de Android y
razonar sobre ellas. Adicionalmente, se presentó un sistema de tipos para este
lenguaje y se demostró un teorema que garantiza que las aplicaciones bien
tipadas preservan la confidencialidad de los datos que manejan. Parcialmente
inspirado en este trabajo, Bugliesi \textit{et al.} desarrollaron
$\pi$-Perm~\cite{bugliesi}, un sistema de tipos y efectos que tiene como
%
\todo{traducción de privilege escalation}
%
finalidad detectar problemas de \textit{privilege escalation}. De manera análoga
al trabajo de Chaudhuri, una expresión bien tipada en $\pi$-Perm garantiza que
la aplicación real a la cual está representando, no es vulnerable al ataque
mencionado. Similarmente, Armando \textit{et al.} definen un
lenguaje~\cite{armando}, junto a su semántica operacional, que permite describir
interacciones entre aplicaciones. También definen un sistema de tipos y efectos
basado en un formalismo del estilo del álgebra de procesos, conocido como
\textit{history expressions}~\cite{history-expressions}. Intuitivamente, una
\textit{history expression} sirve para representar los efectos laterales
vinculados a la seguridad del dispositivo que se producen en una computación.
Finalmente, los autores prueban que cualquier comportamiento que la plataforma
pueda tener en \textit{runtime} está contenido en este modelo, y por lo tanto,
puede analizarse estáticamente.

Recientemente, Wilayar Khan \textit{et al.} retomaron el trabajo de Chaudhuri y
modelaron el lenguaje en él definido dentro del \textit{framework}
lógico-matemático Coq~\cite{coq}. De esta forma, pudieron no solo estudiar la
corrección y seguridad de las aplicaciones de manera mecánica y rigurosa, sino
que también utilizaron este asistente para probar la corrección -o
\textit{soundness}- del lenguaje en sí. En otro trabajo actual encabezado por
Khan~\cite{crashsafe}, se definió en Coq un modelo para estudiar el sistema de
comunicación entre componentes. El principal objetivo de este trabajo es
analizar la robustez de la plataforma cuando una aplicación detiene su ejecución
a causa de un fallo en la resolución de un \textit{intent}. A diferencia del
resto de los trabajos citados, éste se concentra en estudiar propiedades de
\textit{safety} y no de \textit{security}, a pesar de que este sistema puede ser
explotado para filtrar información sensible de los usuarios~\cite{iccta}.

Por otra parte, Bagheri \textit{et al.}~\cite{bagheri15} proponen una
formalización del sistema de permisos de Android escrita en Alloy~\cite{alloy},
un lenguaje basado en la lógica relacional de primer orden,
%
\todo{traducción de bounded verifiaction?}
%
análisis capaz de realizar \textit{bounded verification} de los modelos que en
este lenguaje se describan. Con la ayuda de este modelo, los autores
identificaron distintos tipos de vulnerabilidades que permiten esquivar por
completo el chequeo de permisos. Particularmente, estudiaron la vulnerabilidad
de permisos personalizados, mediante la cual una aplicación maliciosa puede
acceder a todos los recursos de otra que estén protegidos por permisos
personalizados. Esta falla surge de que el sistema no impone restricciones con
respecto al nombre de los nuevos permisos que definen y, como consecuencia, dos
permisos distintos podrían tener el mismo nombre. Este trabajo luego se extendió
para una nueva versión de Android~\cite{bagheri}. La falla por permisos
personalizados ya había sido reportada por Shin \textit{et al.}
en~\cite{shin-custom}.
%
\todoCarlos{debería profundizar más en la diferencia?}
%
Una diferencia fundamental entre este enfoque y el de esta tesina es el tipo de
análisis que se realizó. A pesar de que Alloy es capaz de producir
contraejemplos de manera automática, algo realmente útil a la hora de buscar
potenciales fallas; no es posible demostrar propiedades de una manera rigurosa y
formal.

En trabajos previos encabezados por Gustavo Betarte y Carlos
Luna~\cite{betarte-2017, betarte-2016, luna-cleiej}, se utilizó el asistente de
%
\todo{explicar de qué se trata un sist. de trans. de estados?}
%
pruebas Coq para modelar un sistema de transición de estados que representa,
principalmente, los distintos estados que atraviesa la plataforma cuando se
realizan operaciones sobre ella (por ejemplo, al instalar o desinstalar una
aplicación). A partir de esta especificación, no solo se probaron propiedades
relevantes a la seguridad del modelo, sino que también se extrajo una
implementación certificada del mismo. Los autores explican cómo esta
implementación puede utilizarse para generar casos de pruebas abstractos dentro
del \textit{testing} basado en modelos, o bien, cómo puede usarse para
monitorear las acciones realizadas en un sistema real y evaluar si las
propiedades deseadas efectivamente se cumplen. Estos trabajos presentan el
modelo que será actualizado y extendido en esta tesina.

%%%%%%%%%%
% Fragmento tomado de \cite{luna-cleiej}
%%%
% In particular, Shin et al. [42, 43] build a formal framework that represents the
% Android permission system, which is based on the Calculus of Inductive
% Constructions and it is developed in Coq, as we do. However, that formalization
% does not consider, for instance, several aspects of the platform covered in our
% model, namely, the different types of components, the interaction between a
% running instance and the system, the reading/writing operation on a content
% provider and the semantics of the permission delegation mechanism. They also do
% not consider novel aspects of the Android security model, such as managing
% runtime permissions.
%%%
Un enfoque similar a este, es el de Wook Shin \textit{et al.}, quienes también
utilizaron Coq para representar el modelo~\cite{shin}. Sin embargo, esta
formalización no considera aspectos de la plataforma que sí son considerados por
los trabajos anteriores (y por ende, por esta tesina); como por ejemplo, los
distintos tipos de componentes, la interacción entre instancias de aplicaciones
en ejecución y el sistema, la operación de escritura/lectura en un
\textit{content provider} y la semántica del sistema de delegación de permisos.
Al mismo tiempo, cuando Android incorporó los permisos otorgados en
\textit{runtime}, este modelo no fue actualizado. El trabajo de Fragkaki \textit{et al.}
tambień presenta un modelo formal basado en transiciones de
estado~\cite{fragkaki}, pero el mismo no está desarrolado dentro de un
\textit{framework} que permita realizar pruebas asisistidas por computadora.
Además, el modelo se corresponde con una de las primeras versiones de Android,
por lo que tampoco contempla los cambios en el sistema de permisos introducidos
a partir de la versión 6.0.