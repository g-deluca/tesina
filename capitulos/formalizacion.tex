\chapter{Formalización del sistema de permisos}
\label{chapter:formalization}

En este capítulo describiremos la extensión que realizamos sobre una formalización
previa\cite{luna-cleiej} del sistema de permisos de la plataforma para modelar los nuevos
comportamientos que se introdujeron con las versiones 7, 8, 9 y 10 del sistema operativo. También
presentaremos las propiedades más importantes que extrajimos del modelo, focalizándonos en aquellas
nuevas o en las que se han visto considerablemente afectadas en las nuevas versiones.


\section{Lenguaje formal utilizado}
\label{section:formalization:formal-language}
La especificación del sistema se realizó dentro del framework de trabajo Coq~\cite{coq}. Coq es un
asistente de pruebas interactivo, que permite el desarrollo de programas consistentes con su especificación.
Para lograrlo, provee tres aspectos fundamentales:
\begin{enumerate}
    \item Un lenguaje de especificación que permite escribir expresiones lógicas de alto orden, algoritmos y teoremas;
    \item Un asistente de pruebas que permite desarrollar pruebas matemáticas verificadas;
    \item Una herramienta de extracción de programas, que permite sintetizar programas en lenguajes
    como OCaml~\cite{ocaml} o Haskell~\cite{haskell} a partir de las especificaciones formales escritas
    previamente. Los programas construidos de esta manera suelen llamarse \textit{programas
    certificados}. 
\end{enumerate}

El lenguaje lógico subyacente usado por Coq es el Cálculo de Construcciones Inductivas~\cite{cic}
(también conocido como CIC, por sus siglas en inglés).

\section{Notación}
En las siguientes secciones  utilizaremos la misma notación de los trabajos
previos~\cite{luna-cleiej,betarte-2017,betarte-2016}. La misma es similar a la sintaxis de Haskell.

\subsection{Estructuras de datos y tipos generales}
TODO: COMPLETAR ESTA SECCIÓN

Los diccionarios (más conocidos como \textit{records} por su nombre en inglés) tendrán la forma $\{
l_1: T_1, ..., l_n: T_n \}$ y notaremos el acceso a cada uno de sus elementos como $r.l_n$. También
usaremos $\{ T \}$ para definir el tipo del conjunto que contiene elementos de tipo $T$. 

Definir tipos inductivos blablabla

Para denotar el tipo de las funciones utilizaremos el símbolo $ \rightarrow$. Por ejemplo, una función
$f$ que toma un argumento de tipo $A$ y uno de tipo $B$ y devuelve un valor de tipo $C$, se notará
como $F: A \rightarrow B \rightarrow C$. Usaremos siempre la notación currificada.

\subsection{Tipos básicos de Coq}
A continuación detallaremos algunos de los tipos básicos de Coq más utilizados en esta tesina.
\subsubsection*{Tipo \textit{option}} 
\begin{flalign*}
    Inductive\ option\ T\ &:= &&\\
    &|\ Some\ :\ T \rightarrow\ option\ T&&\\
    &|\ None\ :\ option\ T &&
\end{flalign*}
    

El tipo \texttt{option}, análogo a la mónada \texttt{Maybe} de Haskell\cite{maybe-haskell}, sirve para
representar la posible ausencia de valores. Dado que en Coq no es posible definir funciones
parciales, utilizaremos este tipo para totalizar a las mismas. De esta manera, una función parcial $g$
de $A$ en $B$, será definida como $g:\ A\ \rightarrow\ option\ B$. 

\subsubsection*{Tipo \textit{list}}
\begin{flalign*}
    Inductive\ list\ T\ &:= &&\\
    &|\ \texttt{(::)}\ :\ T \rightarrow\ list\ T\ \rightarrow\ list\ T\ &&\\
    &|\ nil\ :\ list\ T &&
\end{flalign*}

El tipo utilizado para denotar una lista de elementos. Está definido de manera inductiva, siendo
\texttt{::} un operador de punto fijo. 

\subsubsection*{Tipo \textit{nat}}
Utilizado para denotar a los números naturales.

\subsubsection*{Tipo \textit{Prop}}

Este tipo representa uno de los dos "universos" donde viven las proposiciones lógicas en Coq. El tipo
$Prop$ es impredicativo y por lo tanto, una proposición de este tipo no contiene valor
computacional\cite{proof-irrelevance} y puede ser descartada a la hora de extraer un programa.
Utilizaremos este tipo para escribir teoremas que nos permitan razonar sobre el modelo. El otro
universo que contiene proposiciones lógicas se llama $Set$ y las proposiciones de este tipo sí tienen
valor computacional y deben ser preservadas en los programas extraídos.


\section{Estado del sistema}
\label{section:formalization:state}

\subsection{Formalización de los componentes básicos}

\subsection{Definición de estado}
Nuestra formalización del sistema de permisos de Android puede pensarse como una máquina de estado
abstracta [CITA?]. En este modelo, los estados del sistema están conformados por dos componentes: uno
que almacena la información dinámica del sistema, como las aplicaciones instaladas y los permisos otorgados
a las mismas; y otro que contiene información estática como el manifiesto de cada aplicación. Formalmente:

\begin{align*}
System\ :=\ \{ state: State;\ environment: Environment \}
\end{align*}


El componente $State$ está conformado por los siguientes elementos:

\begin{itemize}
    \item Una lista con los identificadores de las aplicaciones instaladas,
    \item Una lista  información de las aplicaciones \textit{legacy} que ya han sido verificadas por
    el usuario. Es un subconjunto de las aplicaciones inst.
    \item Un mapeo entre las aplicaciones instaladas y los permisos otorgados a cada una de ellas.
    \item Un mapeo entre las aplicaciones instaladas y los grupos de permisos para los cuales el
    usuario ha permitido el otorgamiento automático de permisos. 
    \item Un mapeo entre los componentes que define una aplicación y las instancias en ejecución de
    ellos.
    \item Un mapeo entre los recursos de un proveedor de contenidos para una aplicación y los permisos
    permantentes otorgados sobre el mismo.
    \item Un mapeo entre los recursos de un proveedor de contenidos para una aplicación y los permisos
    temporales otorgados sobre el mismo.
    \item Un mapeo indicando el valor de cada uno de los recursos de una aplicación.
    \item Una lista de los intents que han sido enviados, junto con su emisor.
\end{itemize}

Por otro lado, el componente $Environment$ contiene la siguiente información:

\begin{itemize}
    \item Un mapeo que asocia a cada aplicación con su archivo de manifiesto
    \item Un mapeo que asocia a cada aplicación con el certificado que se utilizó para firmarla
    \item Un mapeo que asocia a las aplicaciones con los permisos definidos por ellas
    \item Una lista de las aplicaciones pre-instaladas del sistema
\end{itemize}

A continuación daremos la definición formal de ambos componentes. El orden en el que se definen los
campos de cada componente es el mismo que el de las numeraciones previas.
\begin{flalign*}
State\ &:=\ \{ &&\\
       &apps:\ list\ idApp; \\
       &alreadyVerified:\ list\ idApp; \\
       &grantedPermGroups:\ mapping\ idApp\ (list\ idGrp); \\
       &perms:\ mapping\ idApp\ (list\ Perm); \\
       &running:\ mapping\ iCmp\ Cmp; \\
       &delPPerms:\ mapping\ (idApp\ *\ CProvider\ *\ uri)\ PType; \\
       &delTPerms:\ mapping\ (iCmp\ *\ CProvider\ *\ uri)\ PType; \\
       &resCont:\ mapping\ (idApp\ *\ res)\ Val; \\
       &sentIntents:\ list\ (iCmp*Intent) \\
\}
\end{flalign*}

\begin{flalign*}
Environment\ &:=\ \{ &&\\
       &manifest:\ mapping\ idApp\ Manifest; \\
       &cert:\ mapping\ idApp\ Cert; \\
       &defPerms:\ mapping\ idApp\ (list\ Perm); \\
       &systemImage:\ list\ SysImgApp; \\
\}
\end{flalign*}

De aquí en adelante, al hablar del estado del sistema, nos estaremos refiriendo al componente
$System$. En caso de que querramos referirnos a alguno de sus subcomponentes seremos explícitos con su
nombre en inglés.

\subsubsection{Estados válidos del sistema}
No todos los elementos que habitan el conjunto definido anteriormente son relevantes al sistema que
queremos estudiar. Por ejemplo, no queremos trabajar sobre un estado en el que una aplicación
pre-instalada del sistema y una aplicación instalada por el usuario puedan tener el mismo
identificador. 

Inicialmente, a la hora de definir los componentes, fue necesario pensar qué condiciones debían
cumplir estos estados para representar estados de Android que tengan sentido. En consecuencia,
definimos una noción de \textbf{estado válido} para restringir el universo de estados a aquellos que
cumplen ciertas condiciones que nos garantizarán que nuestros estados del modelo tienen sentido al
compararlos con estados reales del sistema. Vale aclarar, que nuestra definición de estado válido no
es completa y que, de alguna manera, está focalizada en las propiedades que probaremos luego.

Se definió formalmente un predicado $valid\_state$ que se satisface cuandos se cumplen las siguientes
condiciones:

\begin{itemize}
    \item Todos los componentes, ya sea que pertenezcan a una aplicación instalada por el usuario o a
    una aplicación pre-instalada en el sistema tienen identificadores diferentes.
    \item Ningún componente pertenece a más de una aplicación.
    \item Ningún componente en ejecución es una instancia de un proveedor de contenido (los mismos no se \textit{ejecutan}).
    \item Todo permiso temporalmente otorgado ha sido otorgado a un componente en ejecución y es sobre
    un recurso de un proveedor de contenido existente.
    \item Todo componente en ejecución pertenece a una aplicación instalada en el sistema.
    \item Toda aplicación que establece un valor a un recurso está instalada en el sistema.
    \item El dominio de las funciones parciales que definen el $manifest$, $cert$ y $defPerms$ es el
    conjunto de todas las aplicaciones instaladas por el usuario.
    \item El dominio de las funciones parciales que definen $grantedPermGroups$ y $perm$ es el
    conjunto de todas las aplicaciones del sistema, tanto instaladas por el usuario como
    pre-instaladas.
    \item Todas las aplicaciones del sistema tienen identificadores diferentes.
    \item Todos los permisos definidos por las aplicaciones tienen identificadores diferentes.
    \item Todos los permisos otorgados existen en el sistema.
    \item Todos los intents que han sido enviados tienen identificadores diferentes.
\end{itemize}

\section{Acciones}
Modelamos las operaciones de Android que nos interesan estudiar como un conjunto de acciones
(definidas a través del tipo \texttt{Action}), donde cada una de ellas determina la manera en la que
nuestro sistema puede transicionar.  La tabla~\ref{table:actions} resume todas las acciones
disponibles.

La semántica de las mismas está dada en términos de pre-condición y post-condición. Para ello,
definimos los predicados $Pre$ y $Post$ de manera tal que para que una acción $a$ pueda transicionar
el sistema desde un estado $s$ hacia otro estado $s'$, deberán cumplirse $Pre\ s\ a$ y $Post\ s\ s'\ a$. A
continuación y a modo de ejemplo, nos extenderemos sobre las acciones que han sido introducidas o
modificadas con las últimas actualizaciones del sistema.

\subsubsection{Semántica de \texttt{verifyOldApp}} Esta operación se introdujo al modelo para poder
razonar sobre el nuevo el comportamiento mencionado en la
sección~\ref{subsection:recent-changes:legacy-apps}.

\begin{table}
\caption{Acciones del sistema}
\label{table:actions}
\vspace{0.2cm}
\small
\begin{tabularx}{\linewidth}{|l X|}
	\hline
	$\mathtt{install}~app~m~c~lRes$	& Install application with id $app$, whose manifest is $m$, is signed with certificate $c$ and its resources list is $lRes$. \\
	\hline
	$\mathtt{uninstall}~app$	& Uninstall the application with id $app$. \\
	\hline
	$\mathtt{read}~ic~cp~u$	& The running comp. $ic$ reads the resource corresponding to URI $u$ from content provider $cp$. \\
	\hline
	$\mathtt{write}~ic~cp~u~val$	& The running comp. $ic$ writes value $val$ on the resource corresponding to URI $u$ from content provider $cp$. \\
	\hline
	$\mathtt{startActivity}~i~ic$	& The running comp. $ic$ asks to start an activity specified by the intent $i$. \\
	\hline
	$\mathtt{startActivityRes}~i~n~ic$	& The running comp. $ic$ asks to start an activity specified by the intent $i$, and expects as return a token $n$. \\
	\hline
	$\mathtt{startService}~i~ic$	& The running comp. $ic$ asks to start a service specified by the intent $i$. \\
	\hline
	$\mathtt{sendBroadcast}~i~ic~p$	& The running comp. $ic$ sends the intent $i$ as broadcast, specifying that only those components who have the permission $p$ can receive it. \\
	\hline
	$\mathtt{sendOrdBroadcast}~i~ic~p$	& The running comp. $ic$ sends the intent $i$ as an ordered broadcast, specifying that only those components who have the permission $p$ can receive it. \\
	\hline
	$\mathtt{sendSBroadcast}~i~ic$	& The running comp. $ic$ sends the intent $i$ as a sticky broadcast. \\
	\hline
	$\mathtt{resolveIntent}~i~app$	& Application $app$ makes the intent $i$ explicit. \\
	\hline
	$\mathtt{stop}~ic$	& The running comp. $ic$ finishes its execution. \\
	\hline
	$\mathtt{grantP}~ic~cp~app~u~pt$	& The running comp. $ic$ delegates permanent permissions to application $app$. This delegation enables $app$ to perform operation $pt$ on the resource assigned to URI $u$ from content provider $cp$. \\
	\hline
	$\mathtt{revokeDel}~ic~cp~u~pt$	& The running comp. $ic$ revokes delegated permissions on URI $u$ from content provider $cp$ to perform operation $pt$. \\
	\hline
	$\mathtt{call}~ic~sac$	& The running comp. $ic$ makes the API call $sac$. \\
	\hline
	$\mathtt{grant}~p~app$	& Grant the permission $p$ to the application $app$ with user confirmation. \\ 
	\hline
	$\mathtt{grantAuto}~p~app$	& Grant automatically the permission $p$ to the application $app$ (without user confirmation). \\
	\hline
	$\mathtt{revoke}~p~app$	& Remove an ungrouped permission $p$ from the application $app$. \\
	\hline
	$\mathtt{revokePermGroup}~g~app$	& Remove the every permission of group $g$ from the application $app$. \\
	\hline
	$\mathtt{hasPermission}~p~app$	& Check if the application $app$ has the permission $p$. \\
	\hline
	$\mathtt{receiveIntent}~i~ic~app$	& Application $app$ receives the intent $i$, sent by the running comp. $ic$. \\
	\hline
	$\mathtt{verifyOldApp}~app$	& Application $app$ granted permissions are verified by the user  \\
	\hline
  \end{tabularx}
\end{table}

\section{Ejecuciones}

\section{Propiedades del modelo}